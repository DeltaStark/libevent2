#include "XThread.h"
#include <iostream>
#include <thread>
#include <event.h>
#include "XTask.h"
#ifdef _WIN32

#else
    #include <unistd.h>

#endif
using namespace std;

//激活线程任务的回调函数
static void notify_cb(evutil_socket_t fd, short which, void *arg) {
	XThread *t = (XThread *)arg;
	t->notify(fd, which);
	
}

//线程读管道读端
void XThread::notify(evutil_socket_t fd, short which){
	//水平触发 只要没有接收完成 会再次进来
	char buf[2] = {0};
	int ret = recv(fd, buf, 1, 0);
	if (ret < 0)
		return;
	cout << id << " thread " << buf<<endl;
	XTask *task = NULL;
	//获取任务，并初始化任务
	tasks_mutex.lock();
	if(tasks.empty()){
		tasks_mutex.unlock();
		return;
		}

	task = tasks.front();//先进先出
	tasks.pop_front();
	tasks_mutex.unlock();

	task->Init();
}
void XThread::Start() {
	SetUp();
	//启动线程
	thread th(&XThread::Main, this);//回调函数 对象

	//断开与主线程联系
	th.detach();
}
void XThread::Main() {
	cout << id << " XThread::Main begin" << endl;
	//线程入口函数添加内容  base的分发
	event_base_dispatch(base);



	event_base_free(base);

	cout << id << " XThread::Main end" << endl;
}

bool XThread::SetUp(){
	//windows 用配对socket  linux用管道
#ifdef _WIN32
	//创建一个socketpair 可以互相通信 fds[0]读  fds[1]写
	evutil_socket_t fds[2];
	if(evutil_socketpair(AF_INET,SOCK_STREAM,0,fds)<0){
		cout<<"evutil_socketpair failed"<<endl;
		return false;
	}
	evutil_make_socket_nonblocking(fds[0]);
	evutil_make_socket_nonblocking(fds[1]);//读和写设置为非阻塞
	
#else
	//linux 创建的是管道 只能read write 不能send recv
	int fds[2];
	if (pipe(fds)==-1){
		cerr << "pipe failed!" << endl;
		return false;
	}

#endif
	//读取绑定到event事件中,写入要保存；
	notify_send_fd = fds[1];

	//创建libevent上下文 无锁
	event_config *ev_config = event_config_new();
	event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);

	this->base = event_base_new_with_config(ev_config);
	if (!base) 
   {
		cerr << "create libevent context without lock failed!" << endl;
		return false;
	}
	event_config_free(ev_config);

	

	//添加管道监听事件，用于激活线程执行任务
	event *ev=event_new(base, fds[0], EV_READ | EV_PERSIST, notify_cb, this);//创建 this当前对象的地址

	event_add(ev, 0);



	return true;
}
//线程激活
void XThread::Activate(){
#ifdef _WIN32
	int re=send(this->notify_send_fd, "c", 1, 0);
#else
	int write = send(this->notify_send_fd, "c", 1);
#endif
	if (re<=0){
		cerr << "XThred::activate() failed! " << endl;
	}


}
//添加处理的任务
void XThread::AddTask(XTask *t){
	if (!t) return;
	t->base = this->base;
	tasks_mutex.lock();
	tasks.push_back(t);
	tasks_mutex.unlock();
}

XThread::XThread() {

}

XThread::~XThread() {

}
